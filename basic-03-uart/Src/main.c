/**
 ******************************************************************************
 * @file           : main.c
 * @author        : Juan Francisco Padilla Fuentes <jfpadifu03@gmail.com>
 * @version        : 1.0.0
 * @date           : 2026-02-18
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 * Base project auto-generated by STM32CubeIDE for Visual Studio Code Extension
 * Check copyright and license information in the LICENSE file in the root directory of the project
 *
 ******************************************************************************
 */
#include <stdlib.h>
#include <string.h>

#include "uart.h"

#define MAX_CMD_LEN 64

static uint32_t sampling_freq = 1;

/**
 * @brief  Convert an unsigned integer to a decimal string.
 * @param  val   Value to convert
 * @param  buf   Output buffer (must be at least 11 bytes for a 32-bit value)
 */
static void uint_to_str(uint32_t val, char *buf)
{
	char tmp[11];
	int i = 0;

	if (val == 0)
	{
		buf[0] = '0';
		buf[1] = '\0';
		return;
	}
	while (val > 0)
	{
		tmp[i++] = '0' + (val % 10);
		val /= 10;
	}
	int j = 0;
	while (i > 0)
	{
		buf[j++] = tmp[--i];
	}
	buf[j] = '\0';
}

int main(void)
{
	uint8_t cmd_buffer[MAX_CMD_LEN];
	uint32_t index = 0;

	uart_init();
	uart_print("Serial Command Interface ready!\r\n");

	while(1)
	{
		/* Read one character from UART */
		uint8_t ch = uart_read();

		if (ch == '\n' || ch == '\r')
		{
			/* Null-terminate the received command */
			cmd_buffer[index] = '\0';

			/* Handle "SET_FREQ <value>" command */
			if (strncmp((const char *)cmd_buffer, "SET_FREQ ", 9) == 0)
			{
				/* Parse frequency value */
				int freq = atoi((const char *)&cmd_buffer[9]);
				if (freq > 0)
				{
					/* Update sampling frequency */
					sampling_freq = freq;
					uart_print("OK: Frequency set to ");
					char num[11];
					uint_to_str(sampling_freq, num);
					uart_print(num);
					uart_print(" Hz\r\n");
				}
				else
				{
					uart_print("ERROR: Invalid frequency\r\n");
				}
			}
			/* Handle "GET_STATUS" command */
			else if (strcmp((const char *)cmd_buffer, "GET_STATUS") == 0)
			{
				uart_print("STATUS OK, FREQ=");
				char num[11];
				uint_to_str(sampling_freq, num);
				uart_print(num);
				uart_print("\r\n");
			}
			/* Unknown command */
			else
			{
				uart_print("ERROR: Unknown command\r\n");
			}
			/* Reset buffer index after processing */
			index = 0;
		}
		else if (index < MAX_CMD_LEN - 1)
		{
			/* Append character to command buffer */
			cmd_buffer[index++] = ch;
		}
		else
		{
			/* Reset on overflow */
			index = 0;
			uart_print("ERROR: Overflow. Command too long\r\n");
		}
	}
}
