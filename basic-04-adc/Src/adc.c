/**
 ******************************************************************************
 * @file           : adc.c
 * @author        : Juan Francisco Padilla Fuentes <jfpadifu03@gmail.com>
 * @version        : 1.0.0
 * @date           : 2026-02-19
 * @brief          : ADC source file
 ******************************************************************************
 * @attention
 * Base project auto-generated by STM32CubeIDE for Visual Studio Code Extension
 * Check copyright and license information in the LICENSE file in the root directory of the project
 *
 ******************************************************************************
 */
#include "adc.h"
#include "stm32c031xx.h"


// ADC1 ch1 -> PA1
void adc1_ch1_init(void)
{
	/* Enable clock access to GPIOA */
	RCC->IOPENR |= RCC_IOPENR_GPIOAEN;

	/* Set PA1 mode to analog */
	GPIOA->MODER |= GPIO_MODER_MODE1;

	/* Enable clock access to ADC */
	RCC->APBENR2 |= RCC_APBENR2_ADCEN;

	/* Calibrate ADC */
	ADC1->CR |= ADC_CR_ADCAL;
	while (ADC1->CR & ADC_CR_ADCAL);

	/* Configure sequence - select channel 1 (PA1 = ADC_IN1) */
	ADC1->CHSELR = ADC_CHSELR_CHSEL1;

	/* Enable ADC and wait until ready */
	ADC1->CR |= ADC_CR_ADEN;
	while (!(ADC1->ISR & ADC_ISR_ADRDY));
}

void adc1_ch1_single_conversion(void)
{
	/* Start ADC conversion */
	ADC1->CR |= ADC_CR_ADSTART;
}

void adc1_ch1_start_continuous_conversion(void)
{
	/* Enable continuous conversion */
	ADC1->CFGR1 |= ADC_CFGR1_CONT;

	/* Start ADC conversion */
	ADC1->CR |= ADC_CR_ADSTART;
}

uint32_t adc1_ch1_read(void)
{
	/* Wait for conversion to be complete */
	while(!(ADC1->ISR & ADC_ISR_EOC));

	/* Read converted value */
	return (ADC1->DR);
}